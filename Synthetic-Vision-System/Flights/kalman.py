import numpy as np
import matplotlib.pyplot as plt

def kalman_xy(x, P, measurement, R,
              motion = np.matrix('0. 0. 0. 0.').T,
              Q = np.matrix(np.eye(4))):
    """
    Функция реализует фильтр Калмана для отслеживания движения в 2D пространстве
    
    Параметры:    
    x: начальное состояние - 4-элементный вектор (x0, x1, x0_dot, x1_dot), где:
       x0, x1 - координаты
       x0_dot, x1_dot - скорости по соответствующим координатам
    P: начальная ковариационная матрица неопределенности
    measurement: измеренная позиция
    R: шум измерений 
    motion: внешнее движение, добавляемое к вектору состояния x
    Q: шум движения (той же размерности, что и P)
    """
    # Вызов общей функции калмановской фильтрации с конкретными матрицами перехода
    return kalman(x, P, measurement, R, motion, Q,
                  # Матрица перехода состояния F
                  F = np.matrix('''
                      1. 0. 1. 0.;
                      0. 1. 0. 1.;
                      0. 0. 1. 0.;
                      0. 0. 0. 1.
                      '''),
                  # Матрица измерений H
                  H = np.matrix('''
                      1. 0. 0. 0.;
                      0. 1. 0. 0.'''))

def kalman(x, P, measurement, R, motion, Q, F, H):
    """
    Основная функция фильтра Калмана
    
    Параметры:
    x: начальное состояние
    P: начальная ковариационная матрица неопределенности
    measurement: измеренная позиция (той же размерности, что и H*x)
    R: шум измерений (той же размерности, что и H)
    motion: внешнее движение, добавляемое к вектору состояния x
    Q: шум движения (той же размерности, что и P)
    F: функция следующего состояния: x_prime = F*x
    H: функция измерения: position = H*x

    Возвращает: обновленные значения для (x, P)
    """
    # ЭТАП КОРРЕКЦИИ - обновление x, P на основе измерения    
    # Вычисление разности между измеренной и предсказанной позицией
    y = np.matrix(measurement).T - H * x
    # Вычисление ковариации невязки
    S = H * P * H.T + R  
    # Вычисление усиления Калмана
    K = P * H.T * S.I    
    # Коррекция состояния
    x = x + K*y
    # Коррекция ковариационной матрицы
    I = np.matrix(np.eye(F.shape[0])) 
    P = (I - K*H)*P

    # ЭТАП ПРЕДСКАЗАНИЯ - предсказание x, P на основе движения
    x = F*x + motion
    P = F*P*F.T + Q

    return x, P

def demo_kalman_xy():
    # Инициализация начального состояния
    x = np.matrix('0. 0. 0. 0.').T 
    # Инициализация матрицы неопределенности
    P = np.matrix(np.eye(4))*1000 

    # Создание тестовых данных
    N = 20
    true_x = np.linspace(0.0, 10.0, N)
    true_y = true_x**2  # Параболическая траектория
    # Добавление случайного шума к измерениям
    observed_x = true_x + 0.05*np.random.random(N)*true_x
    observed_y = true_y + 0.05*np.random.random(N)*true_y
    # Отображение зашумленных измерений
    plt.plot(observed_x, observed_y, 'ro')
    
    # Применение фильтра Калмана
    result = []
    R = 0.01**2  # Параметр шума измерений
    for meas in zip(observed_x, observed_y):
        x, P = kalman_xy(x, P, meas, R)
        result.append((x[:2]).tolist())
    
    # Отображение отфильтрованной траектории
    kalman_x, kalman_y = zip(*result)
    plt.plot(kalman_x, kalman_y, 'g-')
    plt.show()

# Запуск демонстрации
demo_kalman_xy()